/*   Copyright (C) 2013-2014 Computer Sciences Corporation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License. */

package ezbake.data.postgres.functional;

import ezbake.base.thrift.EzSecurityToken;
import ezbake.configuration.ClasspathConfigurationLoader;
import ezbake.configuration.EzConfiguration;
import ezbake.configuration.EzConfigurationLoaderException;
import ezbake.thrift.ThriftTestUtils;
import ezbake.thrift.ThriftUtils;
import org.apache.thrift.TException;
import org.junit.After;
import org.junit.Before;
import org.junit.Test;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.Arrays;
import java.util.Properties;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertTrue;

/**
 * Test how visibilities work in EzPostgres. These tests are not designed to
 * document the intended or future behavior. They only demonstrate behavior as
 * it exists today.
 *
 * The tests assume that the mock token generated by EzSecurity will have the
 * formal authorization U, but not TS.
 */
public class VisibilityTest {

    private Connection uConnection;
    private Connection tsConnection;

    @Before
    public void setUp() throws SQLException, TException, EzConfigurationLoaderException {
        Properties properties = new EzConfiguration(new ClasspathConfigurationLoader()).getProperties();
        properties.setProperty("user", properties.getProperty("postgres.username"));
        properties.setProperty("password", properties.getProperty("postgres.password"));

        uConnection = DriverManager.getConnection(
                String.format("jdbc:ezbake:postgresql://%s:%s/%s",
                        properties.getProperty("postgres.host"),
                        properties.getProperty("postgres.port"),
                        properties.getProperty("postgres.db")),
                properties);

        EzSecurityToken tsToken = ThriftTestUtils.generateTestSecurityToken("id", "id", Arrays.asList("U", "S", "TS"));
        properties.setProperty("ezbakeTokenProvider", "ezbake.data.postgres.ExplicitTokenProvider");
        properties.setProperty("ezbakeToken", ThriftUtils.serializeToBase64(tsToken));

        tsConnection = DriverManager.getConnection(
                String.format("jdbc:ezbake:postgresql://%s:%s/%s",
                        properties.getProperty("postgres.host"),
                        properties.getProperty("postgres.port"),
                        properties.getProperty("postgres.db")),
                properties);
    }

    @After
    public void tearDown() throws SQLException {
        uConnection.close();
        tsConnection.close();
    }

    /**
     * Applications can insert rows that they have no access to read.
     */
    @Test
    public void testInsertInvisibleRows() throws SQLException {
        Statement statement = uConnection.createStatement();
        statement.execute("drop table if exists foo;");
        statement.execute("create table foo (x integer, visibility varchar);");

        // U marked row
        statement.execute("insert into foo values (1, E'CwABAAAAAVUA');");

        // TS marked row
        statement.execute("insert into foo values (2, E'CwABAAAAAlRTAA==');");

        ResultSet rs = statement.executeQuery("select count(*) from foo;");
        assertTrue(rs.next());
        assertEquals(1, rs.getInt("count"));

        Statement tsStatement = tsConnection.createStatement();
        rs = tsStatement.executeQuery("select count(*) from foo;");
        assertTrue(rs.next());
        assertEquals(2, rs.getInt("count"));
        tsStatement.close();

        statement.execute("drop table foo;");
        statement.close();
    }

    /**
     * Invisible rows can trigger constraints. This can leak information about the presence of rows.
     */
    @Test(expected = SQLException.class)
    public void testInvisibleRowConstraintViolation() throws SQLException {
        Statement statement = uConnection.createStatement();
        statement.execute("drop table if exists foo;");
        statement.execute("create table foo (x integer unique, visibility varchar);");

        try {
            // U marked row
            statement.execute("insert into foo values (1, E'CwABAAAAAVUA');");

            // TS marked row
            statement.execute("insert into foo values (1, E'CwABAAAAAlRTAA==');");
        } finally {
            statement.execute("drop table foo;");
            statement.close();
        }
    }

    /**
     * Invisible rows cannot be updated.
     */
    @Test
    public void testUpdateProtectsInvisibleRows() throws SQLException {
        Statement statement = uConnection.createStatement();
        statement.execute("drop table if exists foo;");
        statement.execute("create table foo (x integer, visibility varchar);");

        // U marked row
        statement.execute("insert into foo values (1, E'CwABAAAAAVUA');");

        // TS marked row
        statement.execute("insert into foo values (1, E'CwABAAAAAlRTAA==');");

        // Unconditionally update rows
        statement.execute("update foo set x = 2;");

        // The TS row should still be 1
        Statement tsStatement = tsConnection.createStatement();
        ResultSet rs = tsStatement.executeQuery("select count(*) from foo where x = 1;");
        assertTrue(rs.next());
        assertEquals(1, rs.getInt("count"));
        tsStatement.close();

        // The U row should now be 2
        rs = statement.executeQuery("select count(*) from foo where x = 2;");
        assertTrue(rs.next());
        assertEquals(1, rs.getInt("count"));

        statement.execute("drop table foo;");
        statement.close();
    }

    /**
     * Invisible rows cannot be deleted.
     */
    @Test
    public void testDeleteProtectsInvisibleRows() throws SQLException {
        Statement statement = uConnection.createStatement();
        statement.execute("drop table if exists foo;");
        statement.execute("create table foo (x integer, visibility varchar);");

        // U marked row
        statement.execute("insert into foo values (1, E'CwABAAAAAVUA');");

        // TS marked row
        statement.execute("insert into foo values (1, E'CwABAAAAAlRTAA==');");

        // Unconditionally delete rows
        statement.execute("delete from foo;");

        // The TS row should still be 1
        Statement tsStatement = tsConnection.createStatement();
        ResultSet rs = tsStatement.executeQuery("select count(*) from foo where x = 1;");
        assertTrue(rs.next());
        assertEquals(1, rs.getInt("count"));

        // The U row should be gone
        rs = statement.executeQuery("select count(*) from foo;");
        assertTrue(rs.next());
        assertEquals(0, rs.getInt("count"));

        statement.execute("drop table foo;");
        statement.close();
    }

    /**
     * Applications can override authorizations from user tokens. I can't
     * imagine this is right.
     */
    @Test
    public void testOverrideAuthorizations() throws SQLException, TException {
        Statement statement = uConnection.createStatement();
        statement.execute("drop table if exists foo;");
        statement.execute("create table foo (x integer, visibility varchar);");

        // U marked row
        statement.execute("insert into foo values (1, E'CwABAAAAAVUA');");

        // TS marked row
        statement.execute("insert into foo values (2, E'CwABAAAAAlRTAA==');");

        // Mock security hard-codes our authorizations to U, so we can only read the U marked row
        ResultSet rs = statement.executeQuery("select count(*) from foo;");
        assertTrue(rs.next());
        assertEquals(1, rs.getInt("count"));

        // But they can be overridden
        //
        // JDBC (on the service side) prevents us from executing a non-returning query and a returning query in the
        // same statement string. To get around this, we're going to create a temporary table, select into it using our
        // malicious authorizations, update the visibilities in the temp table to be something we can see, then drop
        // the temp table. We could just as easily just update the original table to read what we wanted, or any number
        // of other attacks.
        EzSecurityToken maliciousToken = ThriftTestUtils.generateTestSecurityToken("id", "id", Arrays.asList("U", "S", "TS"));
        statement.execute("create temporary table bar (x integer, visibility varchar);");
        statement.execute(String.format("set ezbake.token = '%s'; insert into bar select * from foo; update bar set visibility = E'CwABAAAAAVUA';",
                ThriftUtils.serializeToBase64(maliciousToken)));

        // Uh oh. Now we can read both rows
        rs = statement.executeQuery("select count(*) from bar;");
        assertTrue(rs.next());
        assertEquals(2, rs.getInt("count"));

        // But the original table is unmodified
        rs = statement.executeQuery("select count(*) from foo;");
        assertTrue(rs.next());
        assertEquals(1, rs.getInt("count"));

        statement.execute("drop table foo;");
        statement.close();
    }
}
